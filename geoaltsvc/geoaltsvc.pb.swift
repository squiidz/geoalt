// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: geoaltsvc.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RegisterReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var firstName: String = String()

  var lastName: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RegisterResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateAlertReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lng: Double = 0

  var message: String = String()

  var ephemeral: Bool = false

  var resolution: UInt32 = 0

  var delay: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateAlertResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetAlertReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lng: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetAlertResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alerts: [Alert] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Alert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var center: Coord {
    get {return _storage._center ?? Coord()}
    set {_uniqueStorage()._center = newValue}
  }
  /// Returns true if `center` has been explicitly set.
  var hasCenter: Bool {return _storage._center != nil}
  /// Clears the value of `center`. Subsequent reads from it will return its default value.
  mutating func clearCenter() {_storage._center = nil}

  var borders: [Coord] {
    get {return _storage._borders}
    set {_uniqueStorage()._borders = newValue}
  }

  var cell: Cell {
    get {return _storage._cell ?? Cell()}
    set {_uniqueStorage()._cell = newValue}
  }
  /// Returns true if `cell` has been explicitly set.
  var hasCell: Bool {return _storage._cell != nil}
  /// Clears the value of `cell`. Subsequent reads from it will return its default value.
  mutating func clearCell() {_storage._cell = nil}

  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var readAt: Int64 {
    get {return _storage._readAt}
    set {_uniqueStorage()._readAt = newValue}
  }

  var delay: Int64 {
    get {return _storage._delay}
    set {_uniqueStorage()._delay = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Coord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lng: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Smallest cell resolution (15)
  var baseCell: UInt64 = 0

  /// Cell id used for indexing 
  var indexCell: UInt64 = 0

  /// Cell id with the resolution
  var realCell: UInt64 = 0

  var resolution: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RegisterReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegisterReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .standard(proto: "first_name"),
    4: .standard(proto: "last_name"),
    5: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeSingularStringField(value: &self.firstName)
      case 4: try decoder.decodeSingularStringField(value: &self.lastName)
      case 5: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 3)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 4)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: RegisterReq) -> Bool {
    if self.email != other.email {return false}
    if self.password != other.password {return false}
    if self.firstName != other.firstName {return false}
    if self.lastName != other.lastName {return false}
    if self.address != other.address {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension RegisterResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegisterResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: RegisterResp) -> Bool {
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension LoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: LoginReq) -> Bool {
    if self.email != other.email {return false}
    if self.password != other.password {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension LoginResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: LoginResp) -> Bool {
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CreateAlertReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateAlertReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lng"),
    3: .same(proto: "message"),
    4: .same(proto: "ephemeral"),
    5: .same(proto: "resolution"),
    6: .same(proto: "delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.lat)
      case 2: try decoder.decodeSingularDoubleField(value: &self.lng)
      case 3: try decoder.decodeSingularStringField(value: &self.message)
      case 4: try decoder.decodeSingularBoolField(value: &self.ephemeral)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.resolution)
      case 6: try decoder.decodeSingularInt64Field(value: &self.delay)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if self.ephemeral != false {
      try visitor.visitSingularBoolField(value: self.ephemeral, fieldNumber: 4)
    }
    if self.resolution != 0 {
      try visitor.visitSingularUInt32Field(value: self.resolution, fieldNumber: 5)
    }
    if self.delay != 0 {
      try visitor.visitSingularInt64Field(value: self.delay, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: CreateAlertReq) -> Bool {
    if self.lat != other.lat {return false}
    if self.lng != other.lng {return false}
    if self.message != other.message {return false}
    if self.ephemeral != other.ephemeral {return false}
    if self.resolution != other.resolution {return false}
    if self.delay != other.delay {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CreateAlertResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateAlertResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ok"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.ok)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: CreateAlertResp) -> Bool {
    if self.ok != other.ok {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension GetAlertReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetAlertReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lng"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.lat)
      case 2: try decoder.decodeSingularDoubleField(value: &self.lng)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: GetAlertReq) -> Bool {
    if self.lat != other.lat {return false}
    if self.lng != other.lng {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension GetAlertResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetAlertResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alerts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.alerts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alerts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alerts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: GetAlertResp) -> Bool {
    if self.alerts != other.alerts {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "center"),
    2: .same(proto: "borders"),
    3: .same(proto: "cell"),
    4: .same(proto: "message"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "read_at"),
    7: .same(proto: "delay"),
  ]

  fileprivate class _StorageClass {
    var _center: Coord? = nil
    var _borders: [Coord] = []
    var _cell: Cell? = nil
    var _message: String = String()
    var _timestamp: Int64 = 0
    var _readAt: Int64 = 0
    var _delay: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _center = source._center
      _borders = source._borders
      _cell = source._cell
      _message = source._message
      _timestamp = source._timestamp
      _readAt = source._readAt
      _delay = source._delay
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._center)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._borders)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._cell)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._timestamp)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._readAt)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._delay)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._center {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._borders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._borders, fieldNumber: 2)
      }
      if let v = _storage._cell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 4)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 5)
      }
      if _storage._readAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._readAt, fieldNumber: 6)
      }
      if _storage._delay != 0 {
        try visitor.visitSingularInt64Field(value: _storage._delay, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Alert) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._center != other_storage._center {return false}
        if _storage._borders != other_storage._borders {return false}
        if _storage._cell != other_storage._cell {return false}
        if _storage._message != other_storage._message {return false}
        if _storage._timestamp != other_storage._timestamp {return false}
        if _storage._readAt != other_storage._readAt {return false}
        if _storage._delay != other_storage._delay {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Coord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Coord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "lat"),
    3: .same(proto: "lng"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularDoubleField(value: &self.lat)
      case 3: try decoder.decodeSingularDoubleField(value: &self.lng)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 2)
    }
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Coord) -> Bool {
    if self.lat != other.lat {return false}
    if self.lng != other.lng {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Cell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Cell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_cell"),
    2: .standard(proto: "index_cell"),
    3: .standard(proto: "real_cell"),
    4: .same(proto: "resolution"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.baseCell)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.indexCell)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.realCell)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.resolution)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.baseCell != 0 {
      try visitor.visitSingularUInt64Field(value: self.baseCell, fieldNumber: 1)
    }
    if self.indexCell != 0 {
      try visitor.visitSingularUInt64Field(value: self.indexCell, fieldNumber: 2)
    }
    if self.realCell != 0 {
      try visitor.visitSingularUInt64Field(value: self.realCell, fieldNumber: 3)
    }
    if self.resolution != 0 {
      try visitor.visitSingularUInt32Field(value: self.resolution, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Cell) -> Bool {
    if self.baseCell != other.baseCell {return false}
    if self.indexCell != other.indexCell {return false}
    if self.realCell != other.realCell {return false}
    if self.resolution != other.resolution {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
